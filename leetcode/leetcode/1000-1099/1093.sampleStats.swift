//
//  1093.sampleStats.swift
//  debugTest
//
//  Created by Xiaonan Chen on 2020/12/31.
//

import Foundation

/*
 1093. 大样本统计
 难度
 中等

 17

 我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 的采样个数。

 我们以 浮点数 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。

 我们先来回顾一下中位数的知识：

 如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；
 如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。

 示例 1：

 输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
 输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
 示例 2：

 输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
 输出：[1.00000,4.00000,2.18182,2.00000,1.00000]

 提示：

 count.length == 256
 1 <= sum(count) <= 10^9
 计数表示的众数是唯一的
 答案与真实值误差在 10^-5 以内就会被视为正确答案

 */

func sampleStats(_ count: [Int]) -> [Double] {
    var i = 0
    var j = count.count - 1
    var sum = 0.0
    var ans = [Double](repeating: -1, count: 5)
    var c = 0
    var man = 0

    while i < j {
        if count[i] == 0 {
            i += 1
            continue
        }
        if count[j] == 0 {
            j -= 1
            continue
        }
        if count[i] != 0 {
            sum += Double(count[i] * i)
            c += count[i]
            if man < count[i] {
                man = count[i]
                ans[4] = Double(i)
            }
            if ans[0] == -1 {
                ans[0] = Double(i)
            }
            i += 1
        }
        if count[j] != 0 {
            sum += Double(count[j] * j)
            c += count[j]
            if man < count[j] {
                man = count[j]
                ans[4] = Double(j)
            }
            if ans[1] == -1 {
                ans[1] = Double(j)
            }
            j -= 1
        }
    }

    if i == j {
        sum += Double(count[j] * j)
        c += count[j]
        if man < count[j] {
            man = count[j]
            ans[4] = Double(j)
        }
        if ans[1] == -1 {
            ans[1] = Double(j)
        }
    }

    ans[2] = sum / Double(c)

    var index = 0
    var p = 0
    var q = 0
    for (i, v) in count.enumerated() {
        if v == 0 {
            continue
        }
        if index <= (c - 1) / 2, (c - 1) / 2 < index + v {
            q = i
        }
        if index <= c / 2, c / 2 < index + v {
            p = i
            break
        }
        index += v
    }

    ans[3] = Double(p + q) / 2

    return ans
}
